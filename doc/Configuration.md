# Configuration file

This document describes the configuration file expected by **ParTeCL-CodeGen**.

## Purpose

The purpose of the configuration file is to describe the input/output interface of the tested functionality.
That is, what are the test inputs that are supplied to the program and what are the test results.

ParTeCL-CodeGen uses this file to generate data structures which will be used to store the test input and output values and transfer them between CPU and GPU memory.
It also uses it to change the input/output interface of the tested functionality as it turns it into an OpenCL kernel.

#### Example

Imagine a simple C program which takes two integer inputs from command line, corresponding to `argv[1]` and `argv[2]` and adds them, storing the result in a variable called `sum`.

A configuration file for this program will look like this:

```
input: int a 1
input: int b 2
result: int res variable: sum 
```

This tells ParTeCL-CodeGen that the test case inputs consist of two values: an integer `a` (corresponding to the first command line argument), an integer `b` (corresponding to the second command line argument). 
It also tells ParTeCL-CodeGen that the expected result is a single integer `res` which corresponds to a variable in the program, called `sum`.

The names given in the configuration (`a`, `b` and `res`) are not important, they can be arbitrary.
The name of the variable `sum` needs to correspond to the variable in the program, which holds the result.

From this configuration, **ParTeCL-GodeGen** generates the following structures, which are then used to transfer values between the CPU and GPU memories:

```
typedef struct partecl_input
{
  int test_case_num;
  int argc;
  int a;
  int b;
} partecl_input;

typedef struct partecl_result
{
  int test_case_num;
  int res;
} partecl_result;
```

## Structure

Each configuration is added on a **new line** in the configuration file.

## Configuration options

Below is the full list of configuration options and how they are used.

* **input:** a test case input, supplied as a command line argument.
  ``` 
  Example:
    input: int a 1
    input: int array[10]
  ```

* **stdin:** test case inputs, supplied through standard input; their type is always `char*`:
  ``` 
  Example:
    stdin: char* array 
    stdin: char* number
  ```

* **result:** the test case result. 
  ``` 
  Example:
    result: int res function: add RET // we expect an integer result
                                      // it is the return value of a function called `add`
    result: int res function: add ARG 1 // we expect an integer result
                                        // it is the first argument of a function called `add`
    result: int array[10] variable: sums  // we expect an array of integers as a result
                                          // it is a variable called `sums`
  ```

* **include:** a header file from the program, which declares custom types, that are used by the inputs and results; this header file will be included before the structures generated by the tool.
  ```
  include: algo.h
  ```
  This will then generate:
  ```
  include "algo.h"

  typedef struct partecl_input
  {
    ...
  } partecl_input;

  typedef struct partecl_result
  {
    ...
  } partecl_result;
  ```

### Declaring of arrays

The user can specify array inputs and results using a constant or variable lenght.
For example, they can specify `result: int array[10] variable: sum` or `result: int array[lenght] variable: output_array`.

When they use variable lenght, that variable should also be declared in the input/result.
For example,

`result: int array[length] variable: output_array`

should also have:

`result: int length variable: output_length` 

in the configuration file.

In this way, the program will generate code which knows to which variable in the code (in this case `output_length`) the variable `length` refers to.
